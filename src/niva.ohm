Niva {

  space += comment
  // statement
  statements = spaces statement (dot statement)* statementSeparator? spaces
  statementSeparator =  dot 
  statement = 
    | returnStatement  -- returnStatement
    | typeDeclaration -- typeDeclarationStatement
    | methodDeclaration -- methodDeclarationStatement
    | assignment -- assignmentStatement
    | switchStatement -- switchStatement
  	| expression  -- expressionStatement
  //  | comment
    



  // TYPE DECLARATION
	typeDeclaration = "type" spaces untypedIdentifier spaces typedProperties
    typedProperties = typedProperty (spaces typedProperty)*
    typedProperty =
	  untypedIdentifier ":" spaces (untypedIdentifier | nestedType) 
	nestedType = "(" spaces typeDeclaration spaces ")"  
    
    
  // METHOD DECLARATION
  
  //methodDeclaration = untypedIdentifier keywordMethodDeclarationArgs whiteSpaces returnTypeDeclaration? spaces "=" spaces methodBody
  
  methodDeclaration = "-"
  	(keywordMethodDeclaration 
    | binaryMethodDeclaration
    | unaryMethodDeclaration )
  
  

  
  keywordMethodDeclaration = untypedIdentifier keywordMethodDeclarationArgs whiteSpaces returnTypeDeclaration? spaces ("=" | "^=") spaces methodBody
  keywordMethodDeclarationArgs = spaces keywordMethodDeclarationArg ( spaces keywordMethodDeclarationArg spaces )*
  
  unaryMethodDeclaration = untypedIdentifier  whiteSpaces unaryMethodDeclarationArgs whiteSpaces returnTypeDeclaration? spaces ("=" | "^=") spaces methodBody
  unaryMethodDeclarationArgs = untypedIdentifier
  
  binaryMethodDeclaration = untypedIdentifier whiteSpaces binaryMethodDeclarationArg whiteSpaces returnTypeDeclaration? spaces ("=" | "^=") spaces methodBody
  // + x::int
  binaryMethodDeclarationArg = binarySelector whiteSpaces identifier

  // min: x::int max: y::int from: z
  keywordMethodDeclarationArg = untypedIdentifier ":" spaces identifier 
  
  methodBody  = methodBodyFull | methodBodyShort
  methodBodyFull = "[" spaces statements? spaces "]"
  methodBodyShort = statement
  
  
  
  switchExpression = spaces switchBranch spaces (switchBranch spaces)*  switchBranchElseStatement? spaces
  switchBranch = "|" whiteSpaces expressionList whiteSpaces "=>" spaces expression spaces 
  expressionList = expression ("," whiteSpaces expression)*
  switchBranchElseStatement = "|=>" whiteSpaces expression 




  returnTypeDeclaration = returnTypeOperator whiteSpaces untypedIdentifier
  returnTypeOperator = "->"
  
  
  // Assignment statement
  
  assignment = assignmentTarget spaces assignmentOp spaces expression
  assignmentTarget = identifier

  // Switch statement
  switchStatement = receiver switchExpression

  receiver = 
  	| primary
    | listLiteral
    | "(" expression ")" -- expressionInBrackets
    | blockConstructor
  

  expression = messageCall | switchExpression
  messageCall = receiver (messages cascadedMessages)?
  
    
    
  // MESSAGES
  messages = (unaryMessage+ binaryMessage* keywordMessage?)  -- unaryFirst
  					  | (binaryMessage+ keywordMessage?) -- binaryFirst
              | (keywordMessage) -- keywordFirst
  
  
  keywordMessage = spaces (keywordM spaces keywordArgument spaces)+ spaces
 
 	
 
  keywordM = ~"and" ~"or" identifier ":"
  keywordArgument = receiver unaryMessage* binaryMessage*
  
  binaryMessage = spaces binarySelector spaces binaryArgument
  binaryArgument = receiver unaryMessage*
  
  unaryMessage  = spaces unarySelector
  unarySelector = ~"and" ~"or" identifier ~":" 
  
  cascadedMessages = (";" messages)*
  
  

  // BLOCKS
  blockConstructor = "[" spaces blockBody spaces "]"
  blockBody = (blockArgList)? spaces statements? 
  blockArgList = blockArgument* "|"
  // blockArgument = ":" identifier spaces
  blockArgument = identifier spaces
  
  // STATEMENT
  returnStatement = returnOp spaces expression
     
  // IDENTEFIER
  
  identifier = typedIdentifier | untypedIdentifier
  untypedIdentifier = ~reservedWord identifierName
  typeName = untypedIdentifier
  typedIdentifier = nestedTypedIdentifier | unaryTypedIdentifier  
  unaryTypedIdentifier = untypedIdentifier "::" unaryType
  nestedTypedIdentifier = unaryTypedIdentifier "::" (nonUnaryType | unaryType)+
  
  
  
  unaryType = typeName
  nonUnaryType = (nestedTypedIdentifier | typeName) ("," whiteSpaces (nestedTypedIdentifier | typeName))+
  
  identifierName = identifierStart identifierPart*
  identifierStart = letter | "$" | "_"
  identifierPart = identifierStart | letter 
  
  
  // LITERALS
  primary = 
    | identifier 
    | anyLiteral 
  
  anyLiteral
    = (stringLiteral | integerLiteral | boolLiteral)
  
    //
  listLiteral = 
  	| "{" spaces "}" -- emptyList
    | "{" listElements "}" -- notEmptyList
  listElements = primary whiteSpaces (","? spaces primary)*
  
  mapLiteral = 
  	| "{" spaces "}" -- emptyMap
    | "{" mapElements "}" -- notEmptyList
  mapElements = mapElement (","? spaces mapElement)*
  mapElement = ":"primary whiteSpaces primary
  
  hashSetLiteral = 
  	| "#{" spaces "}" -- emptyHashSet
    | "#{" listElements "}" -- notEmptyHashSet
  
  //  
  
    
  // StringLiteral
  stringLiteral = "\"" doubleStringCharacter* "\""
  doubleStringCharacter = ~("\"" | "\\" | lineTerminator) sourceCharacter -- nonEscaped
                        | "\\" escapeSequence                             -- escaped
                        | lineContinuation                                -- lineContinuation
  
  
  // IntegerLiteral
  integerLiteral = nonZeroDigit decimalDigit*  -- nonZero
                        | "0"                         -- zero
  decimalDigit = "0".."9"
  nonZeroDigit = "1".."9"
  
  
  // Booleans
  trueLiteral
    = "true"

  falseLiteral
    = "false"

  boolLiteral
    = (falseLiteral | trueLiteral)
     
  // Null
  nullLiteral = "null" ~identifierPart
  
  // OTHER
  sourceCharacter = any
  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
  lineContinuation = "\\" lineTerminatorSequence
  lineTerminatorSequence = "\n" | "\r" ~"\n" | "\u2028" | "\u2029" | "\r\n"
  
  // Escapes
  escapeSequence = unicodeEscapeSequence
                 | characterEscapeSequence  // Must come last.
  unicodeEscapeSequence = "u" hexDigit hexDigit hexDigit hexDigit
  characterEscapeSequence = singleEscapeCharacter
                          | nonEscapeCharacter
  singleEscapeCharacter = "'" | "\"" | "\\" | "b" | "f" | "n" | "r" | "t" | "v"
  nonEscapeCharacter = ~(escapeCharacter | lineTerminator) sourceCharacter
  escapeCharacter = singleEscapeCharacter | decimalDigit | "x" | "u"
  

  // Comment
  comment = singleLineComment
  singleLineComment = "//" (~lineTerminator sourceCharacter)* (lineTerminator | end)
  
  
  // CONST
  reservedWord = keyword | nullLiteral | boolLiteral
  keyword = "type"
  separator = (space | comment)* 
  
  // for binary messages 
  binaryCharacter = "!" | "%" | "&" | "*" | "+"  | "/" | "<" | "==" | ">" | "?" | "@" | "\"" | "~" | "-" | "|>" | "<|" | "||" | "and" | "or"  //"|"   // | "," |  
  binarySelector =  binaryCharacter+

  
  assignmentOp= "="
  returnOp = "^"
  dot = "." spaces
  
  whiteSpaces = whiteSpace*
  whiteSpace = " "
  
}