Niva {

  // STATEMENTS
  statements = 
    | returnStatement dot?  -- returnStatement
    | typeDeclaration dot? -- typeDeclarationStatement
    | methodDeclaration dot? -- methodDeclarationStatement
  	| expression (dot statements)? dot? -- expressionStatement

  // TYPE DECLARATION
	typeDeclaration = "type" spaces untypedIdentifier spaces "=" spaces typedProperties
    typedProperties = typedProperty (spaces "," spaces typedProperty)*
    typedProperty = untypedIdentifier ":" spaces untypedIdentifier
    
  // METHOD DECLARATION
  
  methodDeclaration = untypedIdentifier keywordMethodDeclarationArgs spaces "=" spaces blockConstructor
  
  // min: x::int max: y::int from: z
  keywordMethodDeclarationArgs = spaces keywordMethodDeclarationArg ( spaces keywordMethodDeclarationArg spaces )+
  keywordMethodDeclarationArg = untypedIdentifier ":" spaces identifier 
  
  
  // EXPRESSION
  expression = assignment | basicExpression
  
  assignment = assignmentTarget spaces assignmentOp spaces expression
  assignmentTarget = identifier
  
  basicExpression = primary (messages cascadedMessages)* // Может быть просто x = 4, а может быть x = 4 factorial
  // x = 3 или "asd" или x someMessage
  primary = 
  	| identifier 
    | anyLiteral 
    | expression    
    | "(" expression ")" -- expressionInBrackets
    | blockConstructor

    
    
  // MESSAGES
  messages = (unaryMessage+ binaryMessage* keywordMessage?)  -- unaryFirst
  					  | (binaryMessage+ keywordMessage?) -- binaryFirst
              | (keywordMessage)
  
  
  keywordMessage = spaces (keywordM spaces keywordArgument)+ spaces
  // for keywords messages
  keywordM = identifier ":"
  keywordArgument = primary unaryMessage* binaryMessage*
  
  binaryMessage = spaces binarySelector spaces binaryArgument
  binaryArgument = primary unaryMessage*
  
  unaryMessage  = spaces unarySelector
  unarySelector = identifier ~":" // TODO может быть сделать унари селектором только идентифиеры с маленькой буквы?
  
  cascadedMessages = (";" messages)*
  
  // BLOCKS
  blockConstructor = "[" spaces blockBody spaces "]"
  blockBody = (blockArgument* "|")? spaces statements? 
  // blockArgument = ":" identifier spaces
  blockArgument = identifier spaces
  
  // STATEMENT
  // ReturnStatement
  returnStatement = returnOp spaces expression
     
  // IDENTEFIER
  
  identifier = typedIdentifier | untypedIdentifier
  untypedIdentifier = ~reservedWord identifierName
  type = untypedIdentifier
  typedIdentifier = untypedIdentifier "::" type
  
  identifierName = identifierStart identifierPart*
  identifierStart = letter | "$" | "_"
  identifierPart = identifierStart | letter
  
  
  // LITERALS
  anyLiteral
    = (stringLiteral | integerLiteral | boolLiteral)
    
  // StringLiteral
  stringLiteral = "\"" doubleStringCharacter* "\""
  doubleStringCharacter = ~("\"" | "\\" | lineTerminator) sourceCharacter -- nonEscaped
                        | "\\" escapeSequence                             -- escaped
                        | lineContinuation                                -- lineContinuation
  
  
  // IntegerLiteral
  integerLiteral = nonZeroDigit decimalDigit*  -- nonZero
                        | "0"                         -- zero
  decimalDigit = "0".."9"
  nonZeroDigit = "1".."9"
  
  
  // Booleans
  trueLiteral
    = "true"

  falseLiteral
    = "false"

  boolLiteral
    = (falseLiteral | trueLiteral)
     
  // Null
  nullLiteral = "null" ~identifierPart
  
  // OTHER
  sourceCharacter = any
  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
  lineContinuation = "\\" lineTerminatorSequence
  lineTerminatorSequence = "\n" | "\r" ~"\n" | "\u2028" | "\u2029" | "\r\n"
  
  // Escapes
  escapeSequence = unicodeEscapeSequence
                 | characterEscapeSequence  // Must come last.
  unicodeEscapeSequence = "u" hexDigit hexDigit hexDigit hexDigit
  characterEscapeSequence = singleEscapeCharacter
                          | nonEscapeCharacter
  singleEscapeCharacter = "'" | "\"" | "\\" | "b" | "f" | "n" | "r" | "t" | "v"
  nonEscapeCharacter = ~(escapeCharacter | lineTerminator) sourceCharacter
  escapeCharacter = singleEscapeCharacter | decimalDigit | "x" | "u"
  

  // Comment
  comment = multiLineComment | singleLineComment
  multiLineComment = "/*" (~"*/" sourceCharacter)* "*/"
  singleLineComment = "//" (~lineTerminator sourceCharacter)*
  
  
  // CONST
  reservedWord = keyword | nullLiteral | boolLiteral
  keyword = "type" | "self"
  separator = (space | comment)* 
  
  // for binary messages 
  binaryCharacter = "!" | "%" | "&" | "*" | "+" | "," | "/" | "<" | "=" | ">" | "?" | "@" | "\"" | "~" | "|" | "-"
  binarySelector = binaryCharacter+

  
  assignmentOp= "="
  returnOp = "^"
  dot = "." spaces
  }