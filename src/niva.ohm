Niva {
  // statement
  statements = statement (dot statement)* dot?
  statement = 
    | returnStatement  -- returnStatement
    | typeDeclaration -- typeDeclarationStatement
    | methodDeclaration -- methodDeclarationStatement
    | assignment -- assignmentStatement
  	| expression  -- expressionStatement



  // TYPE DECLARATION
	typeDeclaration = "type" spaces untypedIdentifier spaces "=" spaces typedProperties
    typedProperties = typedProperty (spaces typedProperty)*
    typedProperty =
	  untypedIdentifier ":" spaces (untypedIdentifier | nestedType) 
	nestedType = "(" spaces typeDeclaration spaces ")"  
    
    
  // METHOD DECLARATION
  
  methodDeclaration = untypedIdentifier keywordMethodDeclarationArgs whiteSpaces returnTypeDeclaration? spaces "=" spaces blockConstructor
  
  // min: x::int max: y::int from: z
  keywordMethodDeclarationArgs = spaces (keywordMethodDeclarationArg | unaryMethodDeclarationArgs | binaryMethodDeclarationArgs) ( spaces keywordMethodDeclarationArg spaces )*
  keywordMethodDeclarationArg = untypedIdentifier ":" spaces identifier 
  
  unaryMethodDeclarationArgs = untypedIdentifier
  binaryMethodDeclarationArgs = binarySelector whiteSpaces identifier

  returnTypeDeclaration = returnTypeOperator whiteSpaces untypedIdentifier
  returnTypeOperator = "->"
  
  
  // EXPRESSION
  
  assignment = assignmentTarget spaces assignmentOp spaces expression
  assignmentTarget = identifier
  
  // expressionAsReceiver = expression
  receiver = 
  	| primary
    | listLiteral
    | "(" expression ")" -- expressionInBrackets
    | blockConstructor
  
  expression = receiver (messages cascadedMessages)? // Может быть просто x = 4, а может быть x = 4 factorial
    
    
  // MESSAGES
  messages = (unaryMessage+ binaryMessage* keywordMessage?)  -- unaryFirst
  					  | (binaryMessage+ keywordMessage?) -- binaryFirst
              | (keywordMessage) -- keywordFirst
  
  
  keywordMessage = spaces (keywordM spaces keywordArgument spaces)+ spaces
 
 	
 
  keywordM = identifier ":"
  keywordArgument = receiver unaryMessage* binaryMessage*
  
  binaryMessage = spaces binarySelector spaces binaryArgument
  binaryArgument = receiver unaryMessage*
  
  unaryMessage  = spaces unarySelector
  unarySelector = identifier ~":" // TODO может быть сделать унари селектором только идентифиеры с маленькой буквы?
  
  cascadedMessages = (";" messages)*
  
  

  // BLOCKS
  blockConstructor = "[" spaces blockBody spaces "]"
  blockBody = (blockArgument* "|")? spaces statements? 
  // blockArgument = ":" identifier spaces
  blockArgument = identifier spaces
  
  // STATEMENT
  // ReturnStatement
  returnStatement = returnOp spaces expression
     
  // IDENTEFIER
  
  identifier = typedIdentifier | untypedIdentifier
  untypedIdentifier = ~reservedWord identifierName
  typeName = untypedIdentifier
  typedIdentifier = nestedTypedIdentifier | unaryTypedIdentifier  
  unaryTypedIdentifier = untypedIdentifier "::" unaryType
  nestedTypedIdentifier = unaryTypedIdentifier "::" (nonUnaryType | unaryType)+
  
  
  
  unaryType = typeName
  nonUnaryType = (nestedTypedIdentifier | typeName) ("," whiteSpaces (nestedTypedIdentifier | typeName))+
  
  identifierName = identifierStart identifierPart*
  identifierStart = letter | "$" | "_"
  identifierPart = identifierStart | letter
  
  
  // LITERALS
  primary = 
    | identifier 
    | anyLiteral 
  
  anyLiteral
    = (stringLiteral | integerLiteral | boolLiteral)
  
    //
  listLiteral = 
  	| "[]" -- emptyList
    | "[" elements "]" -- notEmptyList
  elements = primary whiteSpaces ("," spaces primary)*
  //
  
  
    
  // StringLiteral
  stringLiteral = "\"" doubleStringCharacter* "\""
  doubleStringCharacter = ~("\"" | "\\" | lineTerminator) sourceCharacter -- nonEscaped
                        | "\\" escapeSequence                             -- escaped
                        | lineContinuation                                -- lineContinuation
  
  
  // IntegerLiteral
  integerLiteral = nonZeroDigit decimalDigit*  -- nonZero
                        | "0"                         -- zero
  decimalDigit = "0".."9"
  nonZeroDigit = "1".."9"
  
  
  // Booleans
  trueLiteral
    = "true"

  falseLiteral
    = "false"

  boolLiteral
    = (falseLiteral | trueLiteral)
     
  // Null
  nullLiteral = "null" ~identifierPart
  
  // OTHER
  sourceCharacter = any
  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
  lineContinuation = "\\" lineTerminatorSequence
  lineTerminatorSequence = "\n" | "\r" ~"\n" | "\u2028" | "\u2029" | "\r\n"
  
  // Escapes
  escapeSequence = unicodeEscapeSequence
                 | characterEscapeSequence  // Must come last.
  unicodeEscapeSequence = "u" hexDigit hexDigit hexDigit hexDigit
  characterEscapeSequence = singleEscapeCharacter
                          | nonEscapeCharacter
  singleEscapeCharacter = "'" | "\"" | "\\" | "b" | "f" | "n" | "r" | "t" | "v"
  nonEscapeCharacter = ~(escapeCharacter | lineTerminator) sourceCharacter
  escapeCharacter = singleEscapeCharacter | decimalDigit | "x" | "u"
  

  // Comment
  comment = multiLineComment | singleLineComment
  multiLineComment = "/*" (~"*/" sourceCharacter)* "*/"
  singleLineComment = "//" (~lineTerminator sourceCharacter)*
  
  
  // CONST
  reservedWord = keyword | nullLiteral | boolLiteral
  keyword = "type"
  separator = (space | comment)* 
  
  // for binary messages 
  binaryCharacter = "!" | "%" | "&" | "*" | "+"  | "/" | "<" | "==" | ">" | "?" | "@" | "\"" | "~" | "|" | "-"  // | ","
  binarySelector = binaryCharacter+

  
  assignmentOp= "="
  returnOp = "^"
  dot = "." spaces
  
  whiteSpaces = whiteSpace*
  whiteSpace = " "
  
}