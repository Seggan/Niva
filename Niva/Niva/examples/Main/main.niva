//String msg::String.[Int, Int -> Unit] = [
//    str = "sas"
//    msg this: str Int: 1 Int: 2
//]
//
//"sas" msg: [ x, y ->
//     this + x toString + y toString |> echo
//]

//Int msgKeyword::String[Int, Int -> Unit] = [
//    str = "sas"
//    msgKeyword this: str Int: 1 Int: 2
//]
//
//Int msgBinary::String[Int] = [
//    msgBinary this: "sas" Int: 2
//]
//
//Int msgUnary::String[] = [
//    msgUnary this: "sas"
//]
//
//String x::Int y::Int = "keyword" echo
//String + x::Int = "binary" echo
//String foo = "unary" echo

//1 msgKeyword: &String x:y:
//1 msgBinary: &String +
//1 msgUnary: &String foo

//q = {1 2 3} map: &Int inc
//q echo


// type alias
//type Sas = [Int -> Int]
//sas = [x::Int -> x inc]

//sas x: 1 |> echo

// message for type alias
//Sas hi -> Int = this Int: 1
//Sas hi::Int = this Int: hi
//sas hi echo
//sas hi: 2 |> echo
//w = [x::Int -> x inc] hi: 3

//type Sas = [Int -> Int]
//Sas at::Int = this Int: 0 |> + at |> echo
//[x::Int -> x inc] at: 5

type Sas = [ -> Boolean]
Sas whileTrue2: block::[ -> T] -> Unit = this do => [
    block do
    this whileTrue2: block
] |=> Unit

mut i = 0
[i < 3] whileTrue2: [
    i echo
    i <- i inc
]
