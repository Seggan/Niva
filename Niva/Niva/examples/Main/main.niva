//type Assert
//constructor Assert that::Any equals::Any -> Unit = [
//  that != equals => [
//    Error throwWithMessage: "Assertion failed: $that != $equals"
//  ]
//]
//Assert that: "sas" equals: "sas"

//fun <T> Node<T>.addAll(): Int {
//    val v = this.value
//    val l = left
//    val r = right
//    when (v) {
//        is Int -> {
//            val leftSum = left.unpackOr({it.addAll()}, 0)
//            val rightSum = if (r != null) r.addAll() else 0
//            return v + leftSum + rightSum
//        }
//        else -> return 0
//    }
//
//}

//type Person name: String
//Person func::Person.[Int, String -> Int] = 1 //func this: this x: 1 y: "Sas"
////Person func::Person.[Int, String -> Int] =  this func x: 1 y: "Sas"
////Person func::Person.[Int, String -> Int] =  this Int: 1 String: "Sas"
////Person func::Person.[x::Int, y::String -> Int] = this x: 1 y: "Sas"
//
//func = [this::Person, x::Int, y::String -> x inc inc inc]
//func = Person[x::Int, y::String -> x inc inc inc]
//
//x = Person name: "Alice"
//x func: func


type Node v: T next: Node?
constructor Node v::T = Node v: v next: null

Node str -> String =
    next unpack: [ "$v, " + it str] or: "$v"

nodeInt =
Node
    v: 545
    next: (
        Node
            v: "sas"
            next: (Node v: true)
    )

nodeInt str echo



type LinkedList head: Node? tail: Node? size: Int

constructor LinkedList::T empty =
    LinkedList::T head: null tail: null size: 0

LinkedList isEmpty = size == 0
LinkedList str = this isEmpty => "Empty!" |=> head unpackOrError str
LinkedList push: v::T -> LinkedList = [
    head <- Node v: v next: head
    tail == null => tail <- head
    size <- size inc
    ^this
]

LinkedList add: v::T -> LinkedList =
  this isEmpty => [
    this push: v
    this
  ] |=> [
    tail unpack: [
      it next: (Node v: v)
      tail <- it next
      size <- size inc
    ]
    this
  ]


LinkedList at: i::Int -> Node? = [
  mut curr = head
  0..<i forEach: [
    curr unpack: [curr <- it next]
  ]
  ^curr
]

LinkedList forEach::[T -> Unit] =
  0..<size forEach: [
    forEach T: (this at: it |> unpackOrError v)
  ]


LinkedList map::[T -> G] -> LinkedList::G = [
   newLinkedList = LinkedList::G empty
   this forEach: [
     newLinkedList add: (map T: it)
   ]
  ^newLinkedList
]


list = LinkedList::Int empty
list push: 1 |> push: 2 |> push: 3
list add: -1 |> add: -2 |> add: -3
"element 4" echo
list at: 4 |> unpackOrError v echo
"full list" echo
list str echo
list map: [it + 5] |> str echo


